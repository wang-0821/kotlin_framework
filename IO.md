* [1.Linux零拷贝](#1)
* [2.Java零拷贝](#2)
* [3.Reactor模型和Proactor](#3)
* [4.select,poll,epoll](#4)
* [5.TCP连接](#5)
* [6.TCP可靠传输机制](#6)

<h2 id="1">1.Linux零拷贝</h2>
&emsp;&emsp; 零拷贝通常是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。

### Linux IO流程
&emsp;&emsp; 1，DMA(Direct Memory Access，直接内存存取)先将磁盘文件读取到操作系统内核缓冲区。2，将内核缓冲区中的数据，拷贝到应用程序的缓冲区。
3，将应用程序缓冲区中的数据，拷贝到socket网络发送缓冲区(属于操作系统内核缓冲区)。4，将socket缓冲区中的数据，拷贝到网卡，由网卡进行网络传输。
这种传输方式需要涉及到两次DMA拷贝，两次CPU拷贝，四次上下文切换。

     Application Context                 Application Buffer
                                            ^           |
                                CPU Copy    |           |
                                            |           V
     Kernel Context                    Read Buffer  Socket Buffer
                                            ^           |
                                DMA Copy    |           |
                                            |           V
                                           Disk     Network Card
                                           
&emsp;&emsp; 1，在应用程序调用read()方法时，会进行一次上下文切换，从用户态切换到内核态。2，应用程序无法访问内核地址空间的数据，
如果应用程序要操作这些数据，得把内容从内核缓冲区读到用户缓冲区，read()调用方法的返回会引发一次上下文切换，从内核态切换到用户态。
3，使用Socket send()把数据传入到Socket发送缓冲区，会进行一次上下文切换，从用户态切换到内核态。4，send()返回会引发一次上下文切换，
从内核态切换到用户态。

### Linux支持的零拷贝
&emsp;&emsp; 1，mmap内存映射。2，sendfile。3，sendfile + DMA scatter/gather copy。4，splice。

#### mmap
&emsp;&emsp; DMA加载磁盘数据到内核缓冲区后，应用程序缓冲区和内核缓冲区进行映射。内核缓冲区到socket缓冲区，进行一次CPU拷贝。
总共经历一次CPU拷贝，两次DMA拷贝，四次上下文切换。

#### sendfile
&emsp;&emsp; 当调用sendfile时，DMA将磁盘数据复制到内核缓冲区，然后将内核缓冲区的数据直接拷贝到socket缓冲区。会经历一次CPU拷贝，
两次DMA拷贝，两次上下文切换。相比mmp，少了两次上下文切换，但是应用程序不能修改数据，只是单纯进行了一次数据传输。

#### sendfile + DMA scatter/gather copy
&emsp;&emsp; 相比于sendfile，少了内核缓冲区到socket缓冲区的一次CPU数据拷贝。但是需要CPU将内核缓冲区的文件描述符发送到socket缓冲区。
会经历0次CPU拷贝，2次DMA拷贝，两次上下文切换。

            kernel buffer ------> socket buffer  使用append descriptor
            
#### splice
&emsp;&emsp; 从磁盘加载数据到内核缓冲区后，在内核空间直接与socket buffer建立pipeline管道。与sendfile不同，splice不需要硬件支持。
会经历0次CPU拷贝，2次DMA拷贝，2次上下文切换。
    
            kernel buffer --------> socket buffer  
                         set up pipe

<h2 id="2">2.Java零拷贝</h2>
&emsp;&emsp; Java中支持mmap、sendfile。Java中sendfile使用FileChannel.transferTo()方法，transferTo()实现方式也是通过系统调用sendfile()，
Netty是使用FileChannel.transferTo()实现文件传输。

<h2 id="3">3.Reactor模型和Proactor</h2>
&emsp;&emsp; Reactor模型是基于同步I/O的，而Proactor是基于异步I/O操作的。Netty就是基于主从Reactor多线程模型。

<h2 id="4">4.select,poll,epoll</h2>
&emsp;&emsp; select、poll、epoll都是IO多路复用机制，监视多个描述符，一旦某个描述符就绪，就能够通知程序进行相应的读写操作。
select、poll、epoll都是同步IO，因为都需要在读写事件就绪后负责进行读写。

### Select
&emsp;&emsp; select步骤：1，创建所关注事件的描述符集合(fd_set)，对于一个描述符可以关注read、write、exception事件，所以通常要创建三个描述符集合。
2，调用select()等待事件发生。3，轮询所有文件描述符集合中的文件描述符，检查是否有对应的事件发生，如果有，则处理事件。

    Select的优点：单线程，占用资源少，不消耗太多CPU。
    Select的缺点：
        1，每次select都需要把fd_set从用户态拷贝到内核态，这个复制开销在fd很多时，开销会很大。
        2，每次select都需要在内核遍历所有的fd，fd很多时，这个开销也很大。
        3，单个进程能监控的fd数量存在最大限制，32位机器默认是1024，数量超过后，select性能会急剧下降。
        4，select触发方式是水平触发，应用程序如果没有完成对一个已经就绪的文件描述符进行IO操作，
            那么之后每次select调用还是会将这些文件描述符通知进程。
        5，该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的。

### Poll
&emsp;&emsp; poll是linux中引入的，poll与select本质上没有太大区别。poll流程：1，创建描述符集合，设置关注的事件。2，调用poll，等待事件发生。
3，轮询描述符集合，检查事件，处理事件。poll和select的区别在于，poll只有一个描述符集合，每个描述符上分别设置读、写、异常事件，最后轮询的时候，
可以同时检查三种事件。
    
    poll没有最大连接数限制，因为它是基于链表存储的。

### Epoll
&emsp;&emsp; epoll将fd_set描述符列表交给内核，一旦有事件发生，内核把发生事件的描述符列表通知给进程，这样避免了轮询整个描述符列表。
epoll支持水平触发和边缘触发，边缘触发只告诉进程哪些fd刚刚变为就绪状态，并且只会通知一次。epoll提供了三个函数：epoll_create、epoll_ctl、
epoll_wait。
    
    epoll_create：创建一个epoll句柄。
    epoll_ctl：注册要监听的事件类型。
    epoll_wait：等待事件的产生。

    epoll步骤：
        1，使用epoll_create(int size)，创建一个有size个描述符的事件列表。
        2，使用epoll_ctl，给描述符设置所关注的事件，并将它添加到内核的事件列表中。 
        3，使用epoll_wait，等待内核通知事件，得到发生事件的描述符的结构列表。

### Epoll的LT和ET
&emsp;&emsp; 水平触发和边缘触发的区别在于：只要句柄满足某种状态，水平触发就会发出通知。而只有当句柄状态改变时，边缘触发才会发出通知。
LT(Level trigger)是水平触发，大并发情况下，效率低于ET，但编码要求低，不用担心事件丢失。ET(Edge trigger)是边缘触发，并发效率高，对编码的要求高，
容易丢失事件。

    epoll的优点：
        1，没有最大并发连接限制。
        2，通过内核事件监听回调的方式，避免对文件描述符进行轮询，提高效率。
        3，内核和用户空间共享一块内存，使用mmp实现内存映射，确保fd在全过程中只进行一次拷贝。

<h2 id="5">5.TCP连接</h2>
&emsp;&emsp; TCP连接经过三次握手，断开连接经过4次挥手。4此挥手时，断开发起方会在接收到FIN后，发送ACK，并等待2MS，然后再释放资源，
这是由于一个数据包最长存活时间为MSL(Maximum Segment Life)，如果发起方发送了ACK，那么如果另一方如果没收到会重传FIN，一来一回是就是2MSL。
而且，如果没有等待2MSL，那么新建立的连接可能会接收到旧连接的报文。

### CLOSE_WAIT及TIME_WAIT异常
&emsp;&emsp; CLOSE_WAIT只会出现在被断开连接的一方，出现大量CLOSE_WAIT的原因可能是一方发起了断开连接请求，另一方忙于读或者写，
没有关闭连接。TIME_WAIT大量出现，会导致端口耗尽。

    // TCP连接建立过程。
    1，主机A向主机B发起TCP连接，发送一条SYN报文，此时A主机状态从CLOSED变为SYN-SEND。
    2，主机B处于LISTEN状态，主机B接收到SYN包后，状态从LISTEN变成SYN-RECV，然后向主机A发送针对此SYN包的SYN/ACK包，确认收到SYN包。
    3，主机A收到SYN/ACK包后，状态从SYN-SEND转换为ESTABLISHED，然后向主机B发送SYN/ACK包。主机B收到SYN/ACK包后，也进入ESTABLISHED状态，
        此时主机A、B就能进行通信了。

                                A CLOSED                B LISTEN
                                 SYN-SEND ------------> SYN-RECV
                                               SYN
                              ESTABLISHED <------------ 
                                             SYN/ACK
                                          ------------> ESTABLISHED
                                             SYN/ACK

    // TCP连接断开过程。
    1，主机A向主机B发送FIN包，此时主机A状态从ESTABLISHED变成FIN_WAIT_1。
    2，主机B收到主机A发来的FIN包，状态从ESTABLISHED变为CLOSE_WAIT，并向主机A发送ACK包，表示准备断开。主机A在收到ACK包后，
        状态从FIN_WAIT_1变成FIN_WAIT_2，然后等待主机B发送确认断开的包。
    3，主机B在发送完所有未发送的数据包后，会再发送FIN包，此时主机B从CLOSE_WAIT状态，变为LAST_ACK状态。
    4，主机A收到主机B发送来的FIN包后，主机A状态从FIN_WAIT_2变为TIME_WAIT，然后发送ACK包，在等待2MSL后，如果还是没有收到回复，
        那么证明服务器已经正常关闭。主机B收到ACK包后，状态从LAST_ACK变为CLOSED。

                            A ESTABLISHED               B ESTABLISHED
                                FIN_WAIT_1 -----------> CLOSE_WAIT
                                               FIN
                                FIN_WAIT_2 <----------- 
                                               ACK   
                                TIME_WAIT  <----------- LAST_ACK   
                                               FIN
                                           -----------> CLOSED
                                               ACK

<h2 id="6">6.TCP可靠传输机制</h2>
&emsp;&emsp; TCP是一种可靠的数据传输协议。TCP确保数据无差错、不丢失、不重复、按序到达。

    TCP可靠传输特性：
        1，序列号和确认应答信号。
        2，超时重发控制。
        3，连接管理。
        4，滑动窗口控制。
        5，流量控制。
        6，拥塞控制。

### 通过序列号和确认应答信号提高可靠性
&emsp;&emsp; 当发送端的数据到达接收端时，接收端会返回一个已收到消息的通知，这个消息叫确认应答(ACK)，接收端查询接收数据TCP首部中的序列号和数据
长度，将自己下一步应该接收的序列号作为确认应答返回。通过序列号和确认应答号，TCP能识别是否已经接收数据，又能判断是否需要接收，从而实现可靠传输。

### 超时重发
&emsp;&emsp; 超时重发是指在重发数据之前，等待确认应答到来的时间间隔，如果超过这个时间仍未收到确认应答，发送端将进行数据重发。
TCP无论在何种网络环境下都要提供高性能通信，因此每次发包时都会计算往返时间(RTT round trip time)和偏差(RTT波动的时间)，将RTT和偏差时间相加，
重发超时的时间就比这个总和稍大一点。

    在BSD的Unix及Windows中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍，最初其重发超时默认值一般为6秒。数据重发后如果还是收不到
    确认应答，等待确认应答的时间将会以2倍、4倍的指数函数延长。达到一定重发次数后，如果还是没有任何确认应答返回，就会判断网络或接收端发生了异常，
    进而强制关闭连接。

### 连接管理
&emsp;&emsp; TCP通过三次握手建立连接和四次挥手断开连接。在数据通信前做好了通信两端之间的准备工作。在建立连接的时候，可以确定发送数据包的单位，
我们称之为最大消息长度(MSS max segment size)，也就是一个段。最理想的情况是，最大消息长度正好是IP中不会被分片处理的最大数据长度。TCP在发送
数据时，是以MSS的大小将数据进行分割发送，进行重发时也是以MSS为单位。 MSS是在三次握手时，两端主机告诉对方自己能适应的MSS大小，
然后在两者之间选择一个较小的值使用。

    MTU(maximum transmission unit)最大传输单元：是指一种通信协议的某一层上能通过的最大数据包大小，通常与通信接口有关。
    以太网为例，去除以太网的帧头，剩下1500Bytes，这部分用来表示IP层能够使用的字节大小，IP层包含IP首部，TCP、UDP最终都被封装成了IP包。
    
    MSS = MTU - 20Bytes IP首部 - 20Bytes TCP首部，因此以太网的MSS为1460字节，Internet MSS为536字节，超通道MSS为65495字节。
    IP包协议头段总长度占16bit，因此MSS最大值为：2^16 - 1 - 20 - 20 = 65495。TCP会根据MSS，将业务数据分片成若干个IP包，而不是直接将数据
    交给IP层来分片。TCP首部包括：目标端口、源端口、顺序号、确认号、窗口、校验和等。IP首部包括：总长度、目标地址、源地址、首部校验和等。
    
        网络              MTU(Byte)
        超通道             65535
        以太网             1500
        Internet          576

### 滑动窗口
&emsp;&emsp; TCP以段作为发送单位，如果每次发送一个段进行一次确认应答，那么RTT时间越长，网络吞吐量就越差，因为这是基于同步的发送方式。
滑动窗口指无需等待确认应答ACK而继续发送数据的最大值。1，在滑动窗口机制下，前面的ACK丢失也能通过下一个ACK进行确认。2，发送端如果连续3次收到同一个
确认应答包，那么就会将其对应的数据进行重发。

    // ACK确认应答丢失
    如果一个段为1000字节，一个窗口为6000字节，发送端直接发送了6000字节的数据，中间1001的ACK丢失了，但如果后面的2001的ACK正常返回了，
    那么也说明前2000字节的数据都正常读取了，就不需要重传0-1000的数据。

    // 报文丢失
    如果段为1000，窗口为6000，1001-2000段丢失，那么在收到2001-3000时，依然会返回1001的ACK应答包，如果发送端连续收到同一个应答包，那么会重发。


### 流量控制
&emsp;&emsp; 如果发送端发送数据的速度太快，那么会导致接收端的缓冲区很快被填满，此时接收端会丢弃数据，从而导致发送端不断的重发。
TCP利用滑动窗口实现流量控制机制，滑动窗口的大小是通过TCP首部的16位窗口大小字段来通知对方。接收端会在确认应答发送ACK报文时，
将自己的即时窗口大小rwnd(receiver window)填入，并跟随ACK发送。发送方端则根据ACK报文里窗口大小的值来改变自己的发送速度。

    在接收端缓冲区满了之后，会返回窗口大小为0，发送端会停止发送，等接收端处理完缓冲区数据后，会发送一个窗口更新的数据包，
    接收端接收到确认包后才会继续发送数据。如果接收端在超时重发的时间内都没有收到窗口更新或者窗口更新包丢失了，
    那么就没办法正常通信了，为了解决这个问题，TCP每一个连接都会设有一个持续计时器(persistence timer)。
    
    持续计时器：只要TCP连接的一放收到零窗口通知，就启动计时器，若持续计时器设置的时间到期，那么就发送一个零窗口探测数据段。
        持续计时器的值为重传时间的数值，如果发送了零窗口探测数据段，没有收到接收端的响应，那么持续计时器的值将加倍并复位。
        持续计时器的值最大可以增加到门限值，通常为60秒，在这之后发送端不在增加计时器的值，以固定频率发送探测报文，直到窗口更新。

### 拥塞控制
&emsp;&emsp; 某段时间内网络中要发送的数据包太多，设备处理不来就会导致网络性能下降，这就是拥塞。网络中的路由器会有一个数据包处理队列，
当路由器接收到的数据包太多处理不过来，就会导致数据包处理队列过长，此时路由器会丢弃新接收到的数据包，而丢弃数据包会引发TCP重传，
而路由器会继续丢弃重传的数据包，从而导致网络性能急剧下降，引发网络瘫痪。因此TCP要控制数据包发送的数量来避免网络性能的下降。

    有了TCP的滑动窗口控制收发数据以窗口而不是段来进行。但实际上还是会根据MSS来进行IP分片发送，传统的发送需要每次发送都接收ACK，
    才进行下一次发送，滑动窗口能够允许连续发送多个数据包。
    如果一开始连接就发送大量的数据包，那么可能导致网络瘫痪，在拥塞控制中，发送方维持一个拥塞窗口cwnd(congestion window)。
    
    拥塞控制使用了两种算法：慢启动算法、拥塞避免算法。ssthresh(慢启动门限)，cwnd < ssthresh 使用慢启动算法，
        cwnd > ssthresh使用拥塞避免算法，两者相等使用任一算法都行。 无论慢启动阶段还是拥塞避免阶段，出现拥塞(未按时收到ACK)，
        就会把ssthresh值设置为cwnd的一半并且大于等于2.
        
        1，慢启动算法：一开始发送少量数据，试探网络拥堵程度，每个传输轮次后将cwnd加倍。比如开始发送设置cwnd=1报文段，
        在第一轮发送完成后加倍，第二轮窗口中数据都发送完成后再次加倍。但不可能一直指数增加cwnd，因此经过一段时间指数增长后，
        需要换成拥塞避免算法来发送数据。
        2，拥塞避免算法：每个传输轮次后，将cwnd的大小加一，出现网络拥塞就将ssthresh设置为cwnd的一半，并将cwnd设置为1，
        重新执行慢启动算法。
