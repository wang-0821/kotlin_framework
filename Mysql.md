* [1.MySQL架构](#1)
* [2.Schema与数据类型优化](#2)
* [3.创建高性能的索引](#3)

<h2 id="1">1.MySQL架构</h2>
&emsp;&emsp; MySQL拥有分层架构，上层是服务器层的服务和查询执行引擎，下层是存储引擎。

                          MySQL服务器逻辑架构
                            连接／线程处理
                             |        |
                             V        V
                          查询缓存<--解析器
                                      |
                                      V
                                    优化器
                                      |
                                      V
                                   存储引擎
<br>
&emsp;&emsp; 通常解决并发读或写时，通过一个由两种类型的锁组成的锁系统来解决问题。这两种锁被称为共享锁(shared lock)、排他锁(exclusive lock)，
也被成为读锁(read lock)和写锁(write lock)。                   

### 表锁
&emsp;&emsp; 表锁是MySQL中最基本的锁策略，是开销最小的策略。表锁会锁定整张表，一个用户在对表进行写操作时，需要先获得写锁，这会阻塞其他用户
对该表的所有读写操作。只有没有写锁时，其他用户才能获取读锁，读锁之间是不互相阻塞的。写锁拥有比读锁更高的优先级，因此一个写锁请求可能会被插入到
读锁队列的前面。尽管存储引擎可以管理自己的锁，但是MySQL本身还是会使用各种锁实现不同的目的，如服务器会为ALTER TABLE使用表锁。

### 行锁
&emsp;&emsp; 行锁可以最大程度支持并发处理，同时也带来了最大的锁开销。行锁只在存储引擎层实现，而MySQL服务层没有实现。

### 事务
&emsp;&emsp; 事务是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能成功对数据库应用该组查询的全部语句，那么执行该组查询。
如果有任何一条语句因为崩溃或其他原因不能执行，那么所有的语句都不会执行，也就是事务内的语句，要么全部成功，要么全部失败。
要么使用COMMIT提交事务修改的数据持久保留，要么使用ROLLBACK撤销所有的修改。

    START TRANSACTION;
    ......
    COMMIT;
    
#### ACID
&emsp;&emsp; ACID表示原子性(atomicity)、一致性(consistency)、隔离性(isolation)、持久性(durability)。

    原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务要么所有操作执行完成，要么全部失败回滚。
    一致性: 数据库总是从一个一致性的状态转移到另一个一致性的状态。
    隔离性：通常来说，一个事务所做的修改在提交之前，对其他的事务是不可见的。
    持久性：一旦事务提交，那么修改将永久保存到数据库中，即使系统崩溃修改的数据也不会丢失。

### 隔离级别
&emsp;&emsp; 在SQL标准中定义了四种隔离级别：未提交读(READ UNCOMMITTED)、提交读(READ COMMITTED)、可重复读(REPEATABLE READ)、
可串行化(SERIALIZABLE)。
    
    未提交读：事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，这被称为脏读(Dirty Read)。性能上来说，未提交读
            不会比其他级别好太多，但是缺乏其他级别的很多好处，一般实际应用中很少使用。
    
    提交读：一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的。这种级别有时也叫不可重复读，因为两次执行同样的查询可能会得到不同的结果。
    
    可重复读：解决了脏读的问题。是MySQL默认隔离级别。保证了在一个事务中多次读取同样记录的结果是一致的。但是无法解决另一个幻读(Phantom Read)问题。
             幻读是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。
             
    可串行化：是最高的隔离级别。通过强制事务串行化执行，避免了幻读问题。串行化会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁竞争问题。
    
    隔离级别        脏读可能性       不可重复读可能性        幻读可能性       加锁读
    未提交读           是                是                   是           否
    提交读             否                是                   是           否 
    可重复读           否                否                   是           否
    可串行化           否                否                   否           是
    
### 死锁
&emsp;&emsp; 死锁是两个或多个事务在同一资源上互相占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。如果多个事务尝试以不同的顺序锁定资源时，
就可能会产生死锁。InnoDB处理死锁的办法是，将持有最少行级排他锁的事务进行回滚。

### 自动提交
&emsp;&emsp; MySQL默认使用自动提交，也就是如果不是显式的开始一个事务，则每个查询都被当作一个事务执行提交操作。
    
    // 查询是否自动提交
    SHOW VARIABLES LIKE 'AUTOCOMMIT';
    
    // 1表示启用，0表示禁用
    SET AUTOCOMMIT = 1;
    
    // 设置事务隔离级别
    SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
    
### 隐式和显式锁定
&emsp;&emsp; 在事务执行过程中，随时可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁在同一时刻被释放。
InnoDB会根据隔离级别在需要的时候自动加锁，这是隐士锁定。InnoDB也支持通过特定的语句进行显式锁定。

    SELECT ... LOCK IN SHARE MODE
    SELECT ... FOR UPDATE
    
<br>
&emsp;&emsp; InnoDB支持LOCK TABLES和UNLOCK语句，这是在服务器层实现的，和存储引擎无关。建议除了事务中禁用了AUTOCOMMIT，可以使用LOCK TABLES之外，
其他任何时候都不要执行LOCK TABLES。

### 多版本并发控制(MVCC)
&emsp;&emsp; MVCC是行级锁的一个变种，在很多情况下避免了加锁操作，实现了非阻塞的读操作，写操作也之锁定必要的行。MVCC通过保存数据在某个时间点的快照来实现，
不管执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不同的。
InnoDB通过在每行记录后面保存两个隐藏的列来实现。这两个列一个保存行的创建时间，另一个保存行的过期时间(或删除时间)，存储的并不是实际的时间值，
而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

    1，InnoDB只查找版本早于(<=)当前事务版本的数据行，这样可以确保事务读取的行要么是在事务开始前就存在的，要么是事务自身插入或修改的。
    2，行的删除版本要么未定义，要么大于当前事务版本号，可以确保事务读取到的行，在事务开始前未被删除。
    
<br>
&emsp;&emsp; 通过保存两个额外的系统版本号，可以使大多数读操作都不用加锁，但是每行记录都要额外的存储空间，要做更多的行检查，以及额外的维护。
MVCC只在REPEATABLE READ、READ COMMITTED两个隔离级别下工作。

&emsp;&emsp; 在文件系统中，MySQL将每个数据库(schema)保存为数据目录下的一个子目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件，
这个保存了表的定义。

    可以使用SHOW TABLE STATUS LIKE 'table_name'；来查看表相关的信息。
    
### InnoDB
&emsp;&emsp; InnoDB是MySQL默认事务型引擎，是使用最广泛的。InnoDB数据存储在表空间中(tablespace)，表空间是由InnoDB管理的一个黑盒子。

<h2 id="2">2.Schema与数据类型优化</h2>
&emsp;&emsp; MySQL支持的数据类型很多，通常选择类型遵循以下原则。
    
    1，更小的通常更好，应该尽量使用可以正确存储数据的最小数据类型。但要确保没有低估需要存储的值的范围，因为在schema中的多个地方增加数据类型的
        范围是一个非常耗时和痛苦的操作。
    2，简单就好，简单数据类型操作通常需要更少的CPU周期。整型比字符操作代价更低。例如：应该使用MySQL内建类型而不是字符串来存储日期和时间。
        应该用整型存储IP地址。
    3，尽量避免NULL，如果查询中包含为NULL的列，对于MySQL更难优化。因为可为NULL的列使索引、索引统计和值比较都更加复杂，可为NULL的列会使用更多的存储空间，
        在MySQL里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节。要尽量避免索引建在可为NULL的列。
        
<br>
&emsp;&emsp; DATETIME和TIMESTAMP都可以存储相同类型的数据，但是TIMESTAMP只使用DATETIME一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。
另一方面TIMESTAMP允许的时间范围要小很多。

### 整数类型
&emsp;&emsp; 有两种类型的数字：整数(whole number)和实数(real number)。如果存储整数，可以使用：TINYINT(8 bit)、SMALLINT(16 bit)、
MEDIUMINT(24 bit)、INT(32 bit)、BIGINT(64 bit)，它们可以存储的值的范围从-2^(N - 1)到 2^(N - 1) - 1，其中N是存储空间的位数。
整数计算一般使用64位的BIGINT。MySQL可以为整数类型指定宽度，例如INT(11)，它不会限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数，
对于存储来说，INT(1)和INT(20)是一样的。

### 实数类型
&emsp;&emsp; 实数是带有小数部分的数字。FLOAT和DOUBLE支持使用标准的浮点运算进行近似计算。DECIMAL用于存储精确的小数，支持精确计算。
MySQL服务器自身实现了DECIMAL的高精度计算，CPU直接支持原生浮点计算，所以浮点运算明显更快。浮点和DECIMAL都可以指定精度，
对于DECIMAL可以指定小数点前后所允许的最大位数，这会影响列的空间消耗。DECIMAL只是一种存储格式，在计算中DECIMAL会转换为DOUBLE类型。

<br>
&emsp;&emsp; 有多种方法可以指定浮点列所需要的精度，这会使MySQL选择不同的数据类型，或者在存储时对值进行取舍。这些精度定义是非标准的，
因此建议只指定数据类型，不指定精度。浮点类型在存储同样范围的值时，通常比DECIMAL使用更小的空间。FLOAT使用4个字节存储，DOUBLE使用8个字节存储。
因为DECIMAL需要额外的空间和计算开销，因此只在对小数进行精确计算时才使用DECIMAL。

### 字符串类型
&emsp;&emsp; VARCHAR和CHAR类型是最主要的字符串类型。VARCHAR在以下情况使用比较合适：1，字符串列最大长度比平均长度大很多，列更新很少，
所以碎片不是问题。2，使用了UTF-8这种复杂的字符集，每个字符都使用不同的字节数进行存储。InnoDB会把过长的VARCHAR存储为BLOB。

    VARCHAR：用于存储可变长字符串，是最常见的字符串数据类型。比定长类型更节省空间，有种例外，当MySQL表使用ROW_FORMAT=FIXED创建的话，
            每一行都会定长存储，这样会导致浪费空间。VARCHAR需要使用1或2个额外字节记录字符串的长度，长度小于等于255，使用1个字节记录长度。
            在UPDATE时，如果使行变得比原来更长，且页中没有更多的空间可以存储，这种情况下InnoDB需要分裂页来使行可以放进页中内。
    
    CHAR：CHAR类型是定长的，当存储CHAR值时，MySQL会删除所有的末尾空格。在存储格式上，CHAR值会根据需要采用空格进行填充以方便比较。
            CHAR不容易产生碎片。
            
<br>
&emsp;&emsp; 与CHAR、VARCHAR类似的还有BINARY、VARBINARY，它们存储的是二进制字符串。二进制字符串与常规字符串十分相似，但二进制字符串存储的
是字节码，而不是字符。MySQL填充BINARY采用的是\0而不是空格，在检索时也不会去掉填充值。二进制比较比字符比较简单很多，所以也更快。

### BLOB和TEXT类型
&emsp;&emsp; BLOB和TEXT都是为了存储很大数据而设计的字符串数据类型，分别采用二进制和字符串方式存储。字符串类型为：TINYTEXT、SMALLTEXT、
TEXT、MEDIUMTEXT、LONGTEXT。二进制类型为：TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB、LONGBLOB。MySQL会把每个BLOB和TEXT值当作一个独立的对象处理，
存储引擎存储时通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的外部存储区域来进行存储，此时每个值在行内需要1-4个字节存储一个指针，
然后在外部存储区域存储实际的值。

    Memory引擎不支持BLOB和TEXT，所以如果查询使用了BLOB或TEXT列，并且需要使用隐式临时表，将不得不使用MyISAM磁盘临时表，这会导致严重的性能开销。
    如果EXPLAIN执行计划的Extra列包含"Using temporary"，则说明这个查询使用了隐式临时表。
    
### 日期和时间类型
&emsp;&emsp; DATETIME能保存从1001年到9999年，精度为秒，把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关，使用8个字节存储空间。
TIMESTAMP能保存从1970年1月1日以来的秒数，使用4个字节的存储空间，只能表示从1970年到2038年。尽量应该使用TIMESTAMP，比DATETIME空间效率更高。

### MySQL schema设计中的陷阱
&emsp;&emsp; 1，太多的列，MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。
如果定义了一个非常多列的表，然而只有一小部分会实际使用到，那么转换的代价就会非常高。2，太多的关联，MySQL限制每个关联操作最多只能有61张表，
如果希望查询执行得快速且并发性好，单个查询最好在12个表以内做关联。3，全能的枚举，防止过度使用枚举。4，变相的枚举。5，非此发明的NULL，
在确实需要NULL的时候，可以直接使用NULL，避免由于无意义的非空值导致的bug。

### 加快ALTER TABLE操作的速度
&emsp;&emsp; MySQL的ALTER TABLE操作性能对于大表来说是个大问题。MySQL执行大部分修改表结构操作的方法使用新的结构创建一个空表，
从旧表中查出所有的数据插入新表，然后删除旧表。对于常见的场景，可以使用的技巧有两种：1，先在一台不提供服务的机器上执行ALTER TABLE操作，
然后和提供服务的主库进行切换。2，影子拷贝，创建一张跟源表无关的新表，然后通过重命名和删表操作交换两张表。
    
    // 通过ALTER COLUMN来该表列的默认值，会直接修改.frm文件不涉及表数据，因此这个操作很快。
    ALTER COLUMN rental_duration SET DEFAULT 5; 

### 只修改.frm文件
&emsp;&emsp; 有些操作可能不需要重建表：1，移除一个列的AUTO_INCREMENT属性。2，增加、移除、或修改ENUM和SET常量，如果移除的是已经有行数据用到其值的常量，
那么查询会返回一个空字符串值。

    替换.frm文件步骤：
    1，创建一张有同样结构的空表，并进行所需要的修改。
    2，执行FLUSH TABLE WITH READ LOCK。这会关闭所有正在使用的表，并禁止任何表被打开。
    3，交换.frm文件。
    4，执行UNLOCK TABLES来释放第2步的读锁。
    
<h2 id="3">3.创建高性能的索引</h2>
&emsp;&emsp; 在MySQL中，存储引擎使用类似的方法使用索引，先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。索引是在存储引擎层
而不是服务器层实现的。

### B-Tree索引
&emsp;&emsp; 如果没有指明类型，那么一般说的索引是B-Tree索引，使用B-Tree数据结构来存储数据。InnoDB使用B+Tree。InnoDB根据主键引用被索引的行。

    如果不是按照索引的最左列开始查找，则无法使用索引。
    不能跳过索引中的列。
    如果查询中有某个列的范围查询，那么其右边所有的列都无法使用索引优化查找。如果范围查询列值的数量有限，那么可以用多个等于条件来代替范围条件。
    
    B-Tree对如下类型的查询有效：
    1，全值匹配，和索引中的所有列进行匹配。
    2，匹配最左前缀。即只使用索引的第一列。
    3，匹配列前缀。只配置某一列的值的开头部分。
    4，匹配范围值。使用索引的第一列，匹配范围值。
    5，精确匹配某一列并范围匹配另外一列。
    6，只访问索引的查询。即查询只需要访问索引，而无须访问数据行。
    
### 索引的优点
&emsp;&emsp; B-Tree索引按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。
    
    1，索引大大减少了服务器需要扫描的数据量。
    2，索引可以帮助服务器避免排序和临时表。
    3，索引可以将随机I／O变为顺序I／O。
    
### 高性能的索引策略
&emsp;&emsp; 高效的选择和使用索引有很多种方式。

    独立的列：索引不能是表达式的一部分，也不能是函数的参数。例如：SELECT actor_id FROM xxx WHERE actor_id + 1 = 5;
    前缀索引和索引选择性：索引的选择性是指不重复的索引值和数据表的记录总数(#T)的比值，范围从 1/#T到1。索引的选择性越高，查询效率越高。
            唯一索引的选择性为1，查询效率最好。对于BLOB、TEXT，或很长VARCHAR类型的列，必须使用前缀索引，前缀索引的选择性尽量应该接近索引整个列。
    多列索引：1，当出现服务器对多个索引做相交操作时(通常多个AND条件)，通常意味着需要一个包含所有相关列的多行索引，而不是多个独立的单列索引。
            2，当服务器需要对多个索引做联合操作时(通常多个OR条件)，通常需要耗费大量CPU和内存资源在算法的缓存、排序、合并操作上。
            3，优化器不会把这些计算到查询成本中，优化器只关心随机页面读取。这会使查询成本被低估，导致该执行计划还不如直接走全表扫描。
            
<br>
&emsp;&emsp; 根据经验法则，当不需要考虑排序和分组时，将选择性最高的列放在前面是很好的。可能需要根据那些运行频率最高的查询来调整索引列的顺序。