* [1.MySQL架构](#1)

<h2 id="1">1.MySQL架构</h2>
&emsp;&emsp; 通常解决并发读或写时，通过一个由两种类型的锁组成的锁系统来解决问题。这两种锁被称为共享锁(shared lock)、排他锁(exclusive lock)，
也被成为读锁(read lock)和写锁(write lock)。

### 表锁
&emsp;&emsp; 表锁是MySQL中最基本的锁策略，是开销最小的策略。表锁会锁定整张表，一个用户在对表进行写操作时，需要先获得写锁，这会阻塞其他用户
对该表的所有读写操作。只有没有写锁时，其他用户才能获取读锁，读锁之间是不互相阻塞的。写锁拥有比读锁更高的优先级，因此一个写锁请求可能会被插入到
读锁队列的前面。尽管存储引擎可以管理自己的锁，但是MySQL本身还是会使用各种锁实现不同的目的，如服务器会为ALTER TABLE使用表锁。

### 行锁
&emsp;&emsp; 行锁可以最大程度支持并发处理，同时也带来了最大的锁开销。行锁只在存储引擎层实现，而MySQL服务层没有实现。

### 事务
&emsp;&emsp; 事务是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能成功对数据库应用该组查询的全部语句，那么执行该组查询。
如果有任何一条语句因为崩溃或其他原因不能执行，那么所有的语句都不会执行，也就是事务内的语句，要么全部成功，要么全部失败。
要么使用COMMIT提交事务修改的数据持久保留，要么使用ROLLBACK撤销所有的修改。

    START TRANSACTION;
    ......
    COMMIT;
    
#### ACID
&emsp;&emsp; ACID表示原子性(atomicity)、一致性(consistency)、隔离性(isolation)、持久性(durability)。

    原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务要么所有操作执行完成，要么全部失败回滚。
    一致性: 数据库总是从一个一致性的状态转移到另一个一致性的状态。
    隔离性：通常来说，一个事务所做的修改在提交之前，对其他的事务是不可见的。
    持久性：一旦事务提交，那么修改将永久保存到数据库中，即使系统崩溃修改的数据也不会丢失。

### 隔离级别
&emsp;&emsp; 在SQL标准中定义了四种隔离级别：未提交读(READ UNCOMMITTED)、提交读(READ COMMITTED)、可重复读(REPEATABLE READ)、
可串行化(SERIALIZABLE)。
    
    未提交读：事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，这被称为脏读(Dirty Read)。性能上来说，未提交读
            不会比其他级别好太多，但是缺乏其他级别的很多好处，一般实际应用中很少使用。
    
    提交读：一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的。这种级别有时也叫不可重复读，因为两次执行同样的查询可能会得到不同的结果。
    
    可重复读：解决了脏读的问题。是MySQL默认隔离级别。保证了在一个事务中多次读取同样记录的结果是一致的。但是无法解决另一个幻读(Phantom Read)问题。
             幻读是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。
             
    可串行化：是最高的隔离级别。通过强制事务串行化执行，避免了幻读问题。串行化会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁竞争问题。
    
    隔离级别        脏读可能性       不可重复读可能性        幻读可能性       加锁读
    未提交读           是                是                   是           否
    提交读             否                是                   是           否 
    可重复读           否                否                   是           否
    可串行化           否                否                   否           是
    
### 死锁
&emsp;&emsp; 死锁是两个或多个事务在同一资源上互相占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。如果多个事务尝试以不同的顺序锁定资源时，
就可能会产生死锁。InnoDB处理死锁的办法是，将持有最少行级排他锁的事务进行回滚。

### 自动提交
&emsp;&emsp; MySQL默认使用自动提交，也就是如果不是显式的开始一个事务，则每个查询都被当作一个事务执行提交操作。
    
    // 查询是否自动提交
    SHOW VARIABLES LIKE 'AUTOCOMMIT';
    
    // 1表示启用，0表示禁用
    SET AUTOCOMMIT = 1;
    
