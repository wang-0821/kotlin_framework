* [1.MySQL架构](#1)
* [2.Schema与数据类型优化](#2)
* [3.创建高性能的索引](#3)
* [4.查询性能优化](#4)

<h2 id="1">1.MySQL架构</h2>
&emsp;&emsp; MySQL拥有分层架构，上层是服务器层的服务和查询执行引擎，下层是存储引擎。

                          MySQL服务器逻辑架构
                            连接／线程处理
                             |        |
                             V        V
                          查询缓存<--解析器
                                      |
                                      V
                                    优化器
                                      |
                                      V
                                   存储引擎
<br>
&emsp;&emsp; 通常解决并发读或写时，通过一个由两种类型的锁组成的锁系统来解决问题。这两种锁被称为共享锁(shared lock)、排他锁(exclusive lock)，
也被成为读锁(read lock)和写锁(write lock)。                   

### 表锁
&emsp;&emsp; 表锁是MySQL中最基本的锁策略，是开销最小的策略。表锁会锁定整张表，一个用户在对表进行写操作时，需要先获得写锁，这会阻塞其他用户
对该表的所有读写操作。只有没有写锁时，其他用户才能获取读锁，读锁之间是不互相阻塞的。写锁拥有比读锁更高的优先级，因此一个写锁请求可能会被插入到
读锁队列的前面。尽管存储引擎可以管理自己的锁，但是MySQL本身还是会使用各种锁实现不同的目的，如服务器会为ALTER TABLE使用表锁。

### 行锁
&emsp;&emsp; 行锁可以最大程度支持并发处理，同时也带来了最大的锁开销。行锁只在存储引擎层实现，而MySQL服务层没有实现。

### 事务
&emsp;&emsp; 事务是一组原子性的SQL查询，或者说一个独立的工作单元。如果数据库引擎能成功对数据库应用该组查询的全部语句，那么执行该组查询。
如果有任何一条语句因为崩溃或其他原因不能执行，那么所有的语句都不会执行，也就是事务内的语句，要么全部成功，要么全部失败。
要么使用COMMIT提交事务修改的数据持久保留，要么使用ROLLBACK撤销所有的修改。

    START TRANSACTION;
    ......
    COMMIT;
    
#### ACID
&emsp;&emsp; ACID表示原子性(atomicity)、一致性(consistency)、隔离性(isolation)、持久性(durability)。

    原子性：一个事务必须被视为一个不可分割的最小工作单元，整个事务要么所有操作执行完成，要么全部失败回滚。
    一致性: 数据库总是从一个一致性的状态转移到另一个一致性的状态。
    隔离性：通常来说，一个事务所做的修改在提交之前，对其他的事务是不可见的。
    持久性：一旦事务提交，那么修改将永久保存到数据库中，即使系统崩溃修改的数据也不会丢失。

### 隔离级别
&emsp;&emsp; 在SQL标准中定义了四种隔离级别：未提交读(READ UNCOMMITTED)、提交读(READ COMMITTED)、可重复读(REPEATABLE READ)、
可串行化(SERIALIZABLE)。
    
    未提交读：事务中的修改，即使没有提交，对其他事务也是可见的。事务可以读取未提交的数据，这被称为脏读(Dirty Read)。性能上来说，未提交读
            不会比其他级别好太多，但是缺乏其他级别的很多好处，一般实际应用中很少使用。
    
    提交读：一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的。这种级别有时也叫不可重复读，因为两次执行同样的查询可能会得到不同的结果。
    
    可重复读：解决了脏读的问题。是MySQL默认隔离级别。保证了在一个事务中多次读取同样记录的结果是一致的。但是无法解决另一个幻读(Phantom Read)问题。
             幻读是指当某个事务在读取某个范围内的记录时，另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行。
             
    可串行化：是最高的隔离级别。通过强制事务串行化执行，避免了幻读问题。串行化会在读取的每一行数据上都加锁，所以可能导致大量的超时和锁竞争问题。
    
    隔离级别        脏读可能性       不可重复读可能性        幻读可能性       加锁读
    未提交读           是                是                   是           否
    提交读             否                是                   是           否 
    可重复读           否                否                   是           否
    可串行化           否                否                   否           是
    
### 死锁
&emsp;&emsp; 死锁是两个或多个事务在同一资源上互相占用，并请求锁定对方占用的资源，从而导致恶性循环的现象。如果多个事务尝试以不同的顺序锁定资源时，
就可能会产生死锁。InnoDB处理死锁的办法是，将持有最少行级排他锁的事务进行回滚。

### 自动提交
&emsp;&emsp; MySQL默认使用自动提交，也就是如果不是显式的开始一个事务，则每个查询都被当作一个事务执行提交操作。
    
    // 查询是否自动提交
    SHOW VARIABLES LIKE 'AUTOCOMMIT';
    
    // 1表示启用，0表示禁用
    SET AUTOCOMMIT = 1;
    
    // 设置事务隔离级别
    SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;
    
### 隐式和显式锁定
&emsp;&emsp; 在事务执行过程中，随时可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁在同一时刻被释放。
InnoDB会根据隔离级别在需要的时候自动加锁，这是隐士锁定。InnoDB也支持通过特定的语句进行显式锁定。

    SELECT ... LOCK IN SHARE MODE
    SELECT ... FOR UPDATE
    
<br>
&emsp;&emsp; InnoDB支持LOCK TABLES和UNLOCK语句，这是在服务器层实现的，和存储引擎无关。建议除了事务中禁用了AUTOCOMMIT，可以使用LOCK TABLES之外，
其他任何时候都不要执行LOCK TABLES。

### 多版本并发控制(MVCC)
&emsp;&emsp; MVCC是行级锁的一个变种，在很多情况下避免了加锁操作，实现了非阻塞的读操作，写操作也之锁定必要的行。MVCC通过保存数据在某个时间点的快照来实现，
不管执行多长时间，每个事务看到的数据都是一致的。根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不同的。
InnoDB通过在每行记录后面保存两个隐藏的列来实现。这两个列一个保存行的创建时间，另一个保存行的过期时间(或删除时间)，存储的并不是实际的时间值，
而是系统版本号。每开始一个新的事务，系统版本号都会自动递增。事务开始时刻的版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

    1，InnoDB只查找版本早于(<=)当前事务版本的数据行，这样可以确保事务读取的行要么是在事务开始前就存在的，要么是事务自身插入或修改的。
    2，行的删除版本要么未定义，要么大于当前事务版本号，可以确保事务读取到的行，在事务开始前未被删除。
    
<br>
&emsp;&emsp; 通过保存两个额外的系统版本号，可以使大多数读操作都不用加锁，但是每行记录都要额外的存储空间，要做更多的行检查，以及额外的维护。
MVCC只在REPEATABLE READ、READ COMMITTED两个隔离级别下工作。

&emsp;&emsp; 在文件系统中，MySQL将每个数据库(schema)保存为数据目录下的一个子目录。创建表时，MySQL会在数据库子目录下创建一个和表同名的.frm文件，
这个保存了表的定义。

    可以使用SHOW TABLE STATUS LIKE 'table_name'；来查看表相关的信息。
    
### InnoDB
&emsp;&emsp; InnoDB是MySQL默认事务型引擎，是使用最广泛的。InnoDB数据存储在表空间中(tablespace)，表空间是由InnoDB管理的一个黑盒子。

<h2 id="2">2.Schema与数据类型优化</h2>
&emsp;&emsp; MySQL支持的数据类型很多，通常选择类型遵循以下原则。
    
    1，更小的通常更好，应该尽量使用可以正确存储数据的最小数据类型。但要确保没有低估需要存储的值的范围，因为在schema中的多个地方增加数据类型的
        范围是一个非常耗时和痛苦的操作。
    2，简单就好，简单数据类型操作通常需要更少的CPU周期。整型比字符操作代价更低。例如：应该使用MySQL内建类型而不是字符串来存储日期和时间。
        应该用整型存储IP地址。
    3，尽量避免NULL，如果查询中包含为NULL的列，对于MySQL更难优化。因为可为NULL的列使索引、索引统计和值比较都更加复杂，可为NULL的列会使用更多的存储空间，
        在MySQL里也需要特殊处理。当可为NULL的列被索引时，每个索引记录需要一个额外的字节。要尽量避免索引建在可为NULL的列。
        
<br>
&emsp;&emsp; DATETIME和TIMESTAMP都可以存储相同类型的数据，但是TIMESTAMP只使用DATETIME一半的存储空间，并且会根据时区变化，具有特殊的自动更新能力。
另一方面TIMESTAMP允许的时间范围要小很多。

### 整数类型
&emsp;&emsp; 有两种类型的数字：整数(whole number)和实数(real number)。如果存储整数，可以使用：TINYINT(8 bit)、SMALLINT(16 bit)、
MEDIUMINT(24 bit)、INT(32 bit)、BIGINT(64 bit)，它们可以存储的值的范围从-2^(N - 1)到 2^(N - 1) - 1，其中N是存储空间的位数。
整数计算一般使用64位的BIGINT。MySQL可以为整数类型指定宽度，例如INT(11)，它不会限制值的合法范围，只是规定了MySQL的一些交互工具用来显示字符的个数，
对于存储来说，INT(1)和INT(20)是一样的。

### 实数类型
&emsp;&emsp; 实数是带有小数部分的数字。FLOAT和DOUBLE支持使用标准的浮点运算进行近似计算。DECIMAL用于存储精确的小数，支持精确计算。
MySQL服务器自身实现了DECIMAL的高精度计算，CPU直接支持原生浮点计算，所以浮点运算明显更快。浮点和DECIMAL都可以指定精度，
对于DECIMAL可以指定小数点前后所允许的最大位数，这会影响列的空间消耗。DECIMAL只是一种存储格式，在计算中DECIMAL会转换为DOUBLE类型。

<br>
&emsp;&emsp; 有多种方法可以指定浮点列所需要的精度，这会使MySQL选择不同的数据类型，或者在存储时对值进行取舍。这些精度定义是非标准的，
因此建议只指定数据类型，不指定精度。浮点类型在存储同样范围的值时，通常比DECIMAL使用更小的空间。FLOAT使用4个字节存储，DOUBLE使用8个字节存储。
因为DECIMAL需要额外的空间和计算开销，因此只在对小数进行精确计算时才使用DECIMAL。

### 字符串类型
&emsp;&emsp; VARCHAR和CHAR类型是最主要的字符串类型。VARCHAR在以下情况使用比较合适：1，字符串列最大长度比平均长度大很多，列更新很少，
所以碎片不是问题。2，使用了UTF-8这种复杂的字符集，每个字符都使用不同的字节数进行存储。InnoDB会把过长的VARCHAR存储为BLOB。

    VARCHAR：用于存储可变长字符串，是最常见的字符串数据类型。比定长类型更节省空间，有种例外，当MySQL表使用ROW_FORMAT=FIXED创建的话，
            每一行都会定长存储，这样会导致浪费空间。VARCHAR需要使用1或2个额外字节记录字符串的长度，长度小于等于255，使用1个字节记录长度。
            在UPDATE时，如果使行变得比原来更长，且页中没有更多的空间可以存储，这种情况下InnoDB需要分裂页来使行可以放进页中内。
    
    CHAR：CHAR类型是定长的，当存储CHAR值时，MySQL会删除所有的末尾空格。在存储格式上，CHAR值会根据需要采用空格进行填充以方便比较。
            CHAR不容易产生碎片。
            
<br>
&emsp;&emsp; 与CHAR、VARCHAR类似的还有BINARY、VARBINARY，它们存储的是二进制字符串。二进制字符串与常规字符串十分相似，但二进制字符串存储的
是字节码，而不是字符。MySQL填充BINARY采用的是\0而不是空格，在检索时也不会去掉填充值。二进制比较比字符比较简单很多，所以也更快。

### BLOB和TEXT类型
&emsp;&emsp; BLOB和TEXT都是为了存储很大数据而设计的字符串数据类型，分别采用二进制和字符串方式存储。字符串类型为：TINYTEXT、SMALLTEXT、
TEXT、MEDIUMTEXT、LONGTEXT。二进制类型为：TINYBLOB、SMALLBLOB、BLOB、MEDIUMBLOB、LONGBLOB。MySQL会把每个BLOB和TEXT值当作一个独立的对象处理，
存储引擎存储时通常会做特殊处理。当BLOB和TEXT值太大时，InnoDB会使用专门的外部存储区域来进行存储，此时每个值在行内需要1-4个字节存储一个指针，
然后在外部存储区域存储实际的值。

    Memory引擎不支持BLOB和TEXT，所以如果查询使用了BLOB或TEXT列，并且需要使用隐式临时表，将不得不使用MyISAM磁盘临时表，这会导致严重的性能开销。
    如果EXPLAIN执行计划的Extra列包含"Using temporary"，则说明这个查询使用了隐式临时表。
    
### 日期和时间类型
&emsp;&emsp; DATETIME能保存从1001年到9999年，精度为秒，把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，与时区无关，使用8个字节存储空间。
TIMESTAMP能保存从1970年1月1日以来的秒数，使用4个字节的存储空间，只能表示从1970年到2038年。尽量应该使用TIMESTAMP，比DATETIME空间效率更高。

### MySQL schema设计中的陷阱
&emsp;&emsp; 1，太多的列，MySQL的存储引擎API工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。
如果定义了一个非常多列的表，然而只有一小部分会实际使用到，那么转换的代价就会非常高。2，太多的关联，MySQL限制每个关联操作最多只能有61张表，
如果希望查询执行得快速且并发性好，单个查询最好在12个表以内做关联。3，全能的枚举，防止过度使用枚举。4，变相的枚举。5，非此发明的NULL，
在确实需要NULL的时候，可以直接使用NULL，避免由于无意义的非空值导致的bug。

### 加快ALTER TABLE操作的速度
&emsp;&emsp; MySQL的ALTER TABLE操作性能对于大表来说是个大问题。MySQL执行大部分修改表结构操作的方法使用新的结构创建一个空表，
从旧表中查出所有的数据插入新表，然后删除旧表。对于常见的场景，可以使用的技巧有两种：1，先在一台不提供服务的机器上执行ALTER TABLE操作，
然后和提供服务的主库进行切换。2，影子拷贝，创建一张跟源表无关的新表，然后通过重命名和删表操作交换两张表。
    
    // 通过ALTER COLUMN来该表列的默认值，会直接修改.frm文件不涉及表数据，因此这个操作很快。
    ALTER COLUMN rental_duration SET DEFAULT 5; 

### 只修改.frm文件
&emsp;&emsp; 有些操作可能不需要重建表：1，移除一个列的AUTO_INCREMENT属性。2，增加、移除、或修改ENUM和SET常量，如果移除的是已经有行数据用到其值的常量，
那么查询会返回一个空字符串值。

    替换.frm文件步骤：
    1，创建一张有同样结构的空表，并进行所需要的修改。
    2，执行FLUSH TABLE WITH READ LOCK。这会关闭所有正在使用的表，并禁止任何表被打开。
    3，交换.frm文件。
    4，执行UNLOCK TABLES来释放第2步的读锁。
    
<h2 id="3">3.创建高性能的索引</h2>
&emsp;&emsp; 在MySQL中，存储引擎使用类似的方法使用索引，先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。索引是在存储引擎层
而不是服务器层实现的。

### B-Tree索引
&emsp;&emsp; 如果没有指明类型，那么一般说的索引是B-Tree索引，使用B-Tree数据结构来存储数据。InnoDB使用B+Tree。InnoDB根据主键引用被索引的行。

    如果不是按照索引的最左列开始查找，则无法使用索引。
    不能跳过索引中的列。
    如果查询中有某个列的范围查询，那么其右边所有的列都无法使用索引优化查找。如果范围查询列值的数量有限，那么可以用多个等于条件来代替范围条件。
    
    B-Tree对如下类型的查询有效：
    1，全值匹配，和索引中的所有列进行匹配。
    2，匹配最左前缀。即只使用索引的第一列。
    3，匹配列前缀。只配置某一列的值的开头部分。
    4，匹配范围值。使用索引的第一列，匹配范围值。
    5，精确匹配某一列并范围匹配另外一列。
    6，只访问索引的查询。即查询只需要访问索引，而无须访问数据行。
    
### 索引的优点
&emsp;&emsp; B-Tree索引按照顺序存储数据，所以MySQL可以用来做ORDER BY和GROUP BY操作。
    
    1，索引大大减少了服务器需要扫描的数据量。
    2，索引可以帮助服务器避免排序和临时表。
    3，索引可以将随机I／O变为顺序I／O。
    
### 高性能的索引策略
&emsp;&emsp; 高效的选择和使用索引有很多种方式。

    独立的列：索引不能是表达式的一部分，也不能是函数的参数。例如：SELECT actor_id FROM xxx WHERE actor_id + 1 = 5;
    前缀索引和索引选择性：索引的选择性是指不重复的索引值和数据表的记录总数(#T)的比值，范围从 1/#T到1。索引的选择性越高，查询效率越高。
            唯一索引的选择性为1，查询效率最好。对于BLOB、TEXT，或很长VARCHAR类型的列，必须使用前缀索引，前缀索引的选择性尽量应该接近索引整个列。
    多列索引：1，当出现服务器对多个索引做相交操作时(通常多个AND条件)，通常意味着需要一个包含所有相关列的多行索引，而不是多个独立的单列索引。
            2，当服务器需要对多个索引做联合操作时(通常多个OR条件)，通常需要耗费大量CPU和内存资源在算法的缓存、排序、合并操作上。
            3，优化器不会把这些计算到查询成本中，优化器只关心随机页面读取。这会使查询成本被低估，导致该执行计划还不如直接走全表扫描。
            
<br>
&emsp;&emsp; 根据经验法则，当不需要考虑排序和分组时，将选择性最高的列放在前面是很好的。可能需要根据那些运行频率最高的查询来调整索引列的顺序。

### 聚簇索引
&emsp;&emsp; 聚簇索引并不是一种单独的索引类型，而是一种数据存储方式。在InnoDB中，聚簇索引实际上在同一个结构中保存了B-Tree索引和数据行。
当表中有聚簇索引时，数据行实际上存放在索引的叶子页中，聚簇表示数据行和相邻的键值紧凑地存储在一起。因为无法同时把数据行存放在两个不同的地方，
所以一个表只能有一个聚簇索引。InnoDB通过主键聚簇数据，如果没有定义主键，InnoDB会选择一个唯一的非空索引替代，如果没有这样的索引，
InnoDB会隐式的定义一个主键来作为聚簇索引。

    聚簇索引把索引和数据行放在一起，也就是都加载到内存中。
    聚簇数据优点：
        1，可以把相关数据放在一起。根据聚簇索引就能查询数据，避免磁盘IO。
        2，数据访问更快，聚簇索引将索引和数据保存在同一个B-Tree中，因此从聚簇索引中获取数据通常比在非聚簇索引中查找更快。
        3，使用覆盖索引扫描的查询，可以直接使用页节点中的主键值。
        
### InnoDB表中按主键顺序插入行
&emsp;&emsp; 最简单的是使用AUTO_INCREMENT自增列主键。这样每次都是从尾部插入数据，页满了后，会在新页中增加数据。如果是随机顺序插入，
如果要插入的页已经满了，那么将会进行页分裂，页分裂会导致移动大量数据，频繁的页分裂会使页变得稀疏并被不规则地填充，最终数据会有碎片。
在把这些随即值载入到聚簇索引后，也许需要做一次OPTIMIZE TABLE来重建表并优化页的填充。

    在使用InnoDB时应该尽可能地按主键顺序插入数据，并尽可能地使用单调增加的聚簇健的值来插入新行。
    
### 覆盖索引
&emsp;&emsp; 如果一个索引包含(或者说覆盖)所有需要查询的字段的值，那我们就称之为覆盖索引。当发起一个被索引覆盖的查询时(索引覆盖查询)，
EXPLAIN的EXTRA列可以看到"Using index"的信息。

    下列情况，执行计划不会使用覆盖查询：
        1，SELECT选择的字段中含有不在索引中的字段，即索引没有覆盖全部的列。
        2，WHERE条件中不能含有对索引进行LIKE的操作。
        
### 使用索引扫描来排序
&emsp;&emsp; MySQL中有两种方式可以生成有序的结果：1，通过排序操作。2，按索引顺序扫描。如果EXPLAIN的TYPE值为"index"，则说明MySQL使用了索引扫描来做排序。
MySQL可以使用同一个索引既满足排序又用于查找行，如果可能设计索引时应该尽可能地同时满足这两种任务。

    只有当索引的列顺序和ORDER BY子句顺序完全一致，并且所有列的排序方向(正序或倒序)都一样时，MySQL才能使用索引来对结果进行排序。
    
### 索引和锁
&emsp;&emsp; 索引可以让查询锁定更少的行。InnoDB只有在访问行的时候才会对其加锁，而索引能够减少InnoDB访问的行数，从而减少锁的数量。
但这需要InnoDB在存储引擎层能过滤掉所有不需要的行时才有效。如果索引无法过滤掉无效的行，那么在InnoDB检索到数据并返回给服务器层后，
MySQL服务器才能应用WHERE子句，这时已经无法避免锁定行，InnoDB可以在服务器端过滤掉行后就释放锁，但旧版本只有事务提交后才能释放锁。

### 避免多个范围条件
&emsp;&emsp; 如果是多维度的范围查询，可以先把其中一个范围查询转化为一个简单的等值查询。

### 维护索引和表
&emsp;&emsp; 维护表主要有三个目的：找到并修复损坏的表，维护准确的索引统计信息，减少碎片。数据碎片可以通过OPTIMIZE TABLE或者导出再导入的方式
来重新整理数据。

    使用CHECK TABLE通常能找出大多数的表和索引的错误。可以使用REPAIRE TABLE命令来修复损坏的表。
    
    数据碎片有三种：
        1，行碎片，数据行被存储为多个地方的多个片段中。即使查询只从索引中访问一行记录，行碎片也会导致性能下降。
        2，行间碎片，指逻辑上顺序的页或者行在磁盘上不是顺序存储的。
        3，剩余空间碎片，指数据页中有大量的空余空间。
        
<br>
&emsp;&emsp; 在选择索引和编写利用这些索引的查询时，有三个原则：1，当行访问是很慢的。如果服务器从存储中读取一个数据块，只是为了获取其中一行，
那么就浪费了很多工作。2，按顺序访问范围数据是很快的，有两个原因，第一，顺序I／O不需要多次磁盘寻道，所以比随机I／O快很多；第二，如果服务器能按照需要
顺序读取数据，那么就不用额外的排序操作，并且GROUP BY查询也无须再做排序和将行按组进行聚合计算。3，索引覆盖查询是很快的。

<h2 id="4">4.查询性能优化</h2>
&emsp;&emsp; 通常查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并返回结果给客户端。
其中执行是整个生命周期中最重要的阶段，这其中包含了大量为了检索数据到存储引擎的调用，以及调用后的数据处理，包括排序、分组等。

    对于低效的查询，通过下面两个步骤分析总是很有效的：
        1，确认应用程序是否在检索大量超过需要的数据。这通常意味着访问了太多的行，但有时候也可能是访问了太多列。
        2，确认MySQL服务器层是否在分析大量超过需要的数据行。
        
<br>
&emsp;&emsp; MySQL最简单的衡量查询开销的三个指标：响应时间、扫描的行数、返回的行数。
    
    响应时间：服务时间 + 排队时间。服务时间是指数据库处理这个查询真正花了多长时间，排队时间是指服务器因为等待某些资源而没有真正执行查询的时间。
    
    理想情况下扫描的行数和返回的行数应该是相同的，但实际这种情况并不多。例如关联查询时，服务器必须要扫描多行才能生成结果集中的一行。
    扫描的行数对返回的行数的比率通常很小，一般在1:1和10:1之间。
    
    EXPLAIN中的type列反应了访问类型。访问类型有很多种：全表扫描、索引扫描、范围扫描、唯一索引查询、常数引用等，速度从慢到快。
    
### 分解关联查询
&emsp;&emsp; 很多高性能的应用都会对关联查询进行分解。
    
    分解关联查询优势：1，让缓存更高效。2，查询分解后，执行单个查询能减少锁的竞争。3，在应用层做关联，更容易对数据库进行拆分，更容易做到高性能和可扩展。
        4，查询本身的效率也可能会有所提升，有时，使用IN代替关联查询更高效。5，可以减少冗余记录的查询。6，这样做相当于在应用中实现了哈希关联，
        而不是使用MySQL的嵌套循环关联。
        
### 查询执行的基础
&emsp;&emsp; MySQL执行查询的过程。
    
    1，客户端发送一条查询给服务器。
    2，服务器先检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段。
    3，服务器端进行MySQL解析、预处理，再由优化器生成对应的执行计划。
    4，MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。
    5，将结果返回给客户端。
    
<br>
&emsp;&emsp; 对于一个MySQL连接，或者说一个线程，任何时刻都有一个状态，该状态表明MySQL当前正在做什么。使用SHOW FULL PROCRSSLIST命令能够查看当前状态。
    
    Sleep：线程正在等待客户端发送新的请求。
    Query：线程正在执行查询或者正在将结果发送给客户端。
    Locked：在MySQL服务器层，表明线程正在等待表锁。
    Analyzing and statistics：线程正在收集存储引擎的统计信息，并生成查询的执行计划。
    Copying to tmp table：线程正在执行查询，并且将结果集复制到一个临时表中，这种状态一般要么是在做GROUP BY操作，要么是文件排序操作，
            或者是UNION操作。如果这个状态后面还有"on disk"标记，那表示MySQL正在将一个内存临时表放到磁盘上。
    Sorting result：线程正在对结果进行排序。
    Sending data：可能表示多种情况：1，线程可能在多个状态之间传送数据。2，正在生成结果集。2，向客户端返回数据。
    
### 查询优化处理
&emsp;&emsp; 查询的生命周期的下一步是将一个SQL转换成一个执行计划，MySQL再依照这个执行计划和存储引擎交互。包括：解析SQL、预处理、优化SQL执行计划。
    
    语法解析器和预处理：MySQL通过关键字将SQL语句进行解析，并生成一棵对应的解析树。MySQL解析起将使用MySQL语法规则验证和解析查询。
    查询优化器：优化器将语法树转换成执行计划。优化器作用是找到最好的执行计划。MySQl使用基于成本的优化器，尝试预测一个查询使用某种执行计划时的成本，
        并选择其中成本最小的一个。

<br>
&emsp;&emsp; 优化器策略分两种：1，静态优化。2，动态优化。静态优化可以直接对解析树进行分析，并完成优化。动态优化与查询上下文有关，需要在每次查询时都重新评估。
MySQL对查询的静态优化只需要做一次。

    MySQL能够处理的优化类型：
        1，重新定义关联表的顺序。决定关联的顺序是优化器很重要的一部分功能。
        2，将外连接转换为内连接。如果WHERE条件、库表结构能让外连接等价于一个内连接。MySQL能够识别并重写查询条件，让其调整关联顺序。
        3，使用等价交换规则。MySQL可以使用一些等价交换来简化并规范表达式。例如 5 = 5 AND a > 5 将被改写成 a > 5。
        4，优化COUNT()、MIN()、MAX()。索引和列是否可为空通常可以帮助MySQL优化这类表达式。
        5，预估并转化为常数表达式。当MySQL检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行优化处理。
        6，覆盖索引扫描。当索引中的列包含所有查询中需要使用的列的时候，MySQL就可以使用索引返回需要的数据，而无须查询对应的数据行。
        7，子查询优化。MySQL在某些情况下可以将子查询转换一种效率更高的形式，从而减少多个查询多次对数据进行访问。
        8，提前终止查询。在发现已经满足查询需求的时候，MySQL总是能够立刻终止查询。
        9，等值传播。如果两个列的值通过等式关联，那么MySQL能够把其中一个列的WHERE条件传递到另一列上。
        10，列表IN()的比较。在MySQL中，将IN()列表中的数据先进行排序，然后通过二分查找的方式来确定列表中的值是否满足条件。
            这是一个O(log n)复杂度的操作，等价地转换成OR的查询复杂度为O(n)，对于IN()列表中有大量取值的时候，MySQL更快。