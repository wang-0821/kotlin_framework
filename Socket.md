* [1.TCP连接](#1)
* [2.TCP可靠传输机制](#2)

<h2 id="1">1.TCP连接</h2>
&emsp;&emsp; TCP连接经过三次握手，断开连接经过4次挥手。4此挥手时，断开发起方会在接收到FIN后，发送ACK，并等待2MS，然后再释放资源，
这是由于一个数据包最长存活时间为MSL(Maximum Segment Life)，如果发起方发送了ACK，那么如果另一方如果没收到会重传FIN，一来一回是就是2MSL。
而且，如果没有等待2MSL，那么新建立的连接可能会接收到旧连接的报文。

### CLOSE_WAIT及TIME_WAIT异常
&emsp;&emsp; CLOSE_WAIT只会出现在被断开连接的一方，出现大量CLOSE_WAIT的原因可能是一方发起了断开连接请求，另一方忙于读或者写，
没有关闭连接。TIME_WAIT大量出现，会导致端口耗尽。

    // TCP连接建立过程。
    1，主机A向主机B发起TCP连接，发送一条SYN报文，此时A主机状态从CLOSED变为SYN-SEND。
    2，主机B处于LISTEN状态，主机B接收到SYN包后，状态从LISTEN变成SYN-RECV，然后向主机A发送针对此SYN包的SYN/ACK包，确认收到SYN包。
    3，主机A收到SYN/ACK包后，状态从SYN-SEND转换为ESTABLISHED，然后向主机B发送SYN/ACK包。主机B收到SYN/ACK包后，也进入ESTABLISHED状态，
        此时主机A、B就能进行通信了。

                                A CLOSED                B LISTEN
                                 SYN-SEND ------------> SYN-RECV
                                               SYN
                              ESTABLISHED <------------ 
                                             SYN/ACK
                                          ------------> ESTABLISHED
                                             SYN/ACK

    // TCP连接断开过程。
    1，主机A向主机B发送FIN包，此时主机A状态从ESTABLISHED变成FIN_WAIT_1。
    2，主机B收到主机A发来的FIN包，状态从ESTABLISHED变为CLOSE_WAIT，并向主机A发送ACK包，表示准备断开。主机A在收到ACK包后，
        状态从FIN_WAIT_1变成FIN_WAIT_2，然后等待主机B发送确认断开的包。
    3，主机B在发送完所有未发送的数据包后，会再发送FIN包，此时主机B从CLOSE_WAIT状态，变为LAST_ACK状态。
    4，主机A收到主机B发送来的FIN包后，主机A状态从FIN_WAIT_2变为TIME_WAIT，然后发送ACK包，在等待2MSL后，如果还是没有收到回复，
        那么证明服务器已经正常关闭。主机B收到ACK包后，状态从LAST_ACK变为CLOSED。

                            A ESTABLISHED               B ESTABLISHED
                                FIN_WAIT_1 -----------> CLOSE_WAIT
                                               FIN
                                FIN_WAIT_2 <----------- 
                                               ACK   
                                TIME_WAIT  <----------- LAST_ACK   
                                               FIN
                                           -----------> CLOSED
                                               ACK

<h2 id="2">2.TCP可靠传输机制</h2>
&emsp;&emsp; TCP是一种可靠的数据传输协议。TCP确保数据无差错、不丢失、不重复、按序到达。

    TCP可靠传输特性：
        1，序列号和确认应答信号。
        2，超时重发控制。
        3，连接管理。
        4，滑动窗口控制。
        5，流量控制。
        6，拥塞控制。

### 通过序列号和确认应答信号提高可靠性
&emsp;&emsp; 当发送端的数据到达接收端时，接收端会返回一个已收到消息的通知，这个消息叫确认应答(ACK)，接收端查询接收数据TCP首部中的序列号和数据
长度，将自己下一步应该接收的序列号作为确认应答返回。通过序列号和确认应答号，TCP能识别是否已经接收数据，又能判断是否需要接收，从而实现可靠传输。

### 超时重发
&emsp;&emsp; 超时重发是指在重发数据之前，等待确认应答到来的时间间隔，如果超过这个时间仍未收到确认应答，发送端将进行数据重发。
TCP无论在何种网络环境下都要提供高性能通信，因此每次发包时都会计算往返时间(RTT round trip time)和偏差(RTT波动的时间)，将RTT和偏差时间相加，
重发超时的时间就比这个总和稍大一点。
    
    在BSD的Unix及Windows中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍，最初其重发超时默认值一般为6秒。数据重发后如果还是收不到
    确认应答，等待确认应答的时间将会以2倍、4倍的指数函数延长。达到一定重发次数后，如果还是没有任何确认应答返回，就会判断网络或接收端发生了异常，
    进而强制关闭连接。

### 连接管理
&emsp;&emsp; TCP通过三次握手建立连接和四次挥手断开连接。在数据通信前做好了通信两端之间的准备工作。在建立连接的时候，可以确定发送数据包的单位，
我们称之为最大消息长度(MSS max segment size)，也就是一个段。最理想的情况是，最大消息长度正好是IP中不会被分片处理的最大数据长度。TCP在发送
数据时，是以MSS的大小将数据进行分割发送，进行重发时也是以MSS为单位。 MSS是在三次握手时，两端主机告诉对方自己能适应的MSS大小，
然后在两者之间选择一个较小的值使用。
    
    MTU(maximum transmission unit)最大传输单元：是指一种通信协议的某一层上能通过的最大数据包大小，通常与通信接口有关。
    以太网为例，去除以太网的帧头，剩下1500Bytes，这部分用来表示IP层能够使用的字节大小，IP层包含IP首部，TCP、UDP最终都被封装成了IP包。
    
    MSS = MTU - 20Bytes IP首部 - 20Bytes TCP首部，因此以太网的MSS为1460字节，Internet MSS为536字节，超通道MSS为65495字节。
    IP包协议头段总长度占16bit，因此MSS最大值为：2^16 - 1 - 20 - 20 = 65495。TCP会根据MSS，将业务数据分片成若干个IP包，而不是直接将数据
    交给IP层来分片。
    
        网络              MTU(Byte)
        超通道             65535
        以太网             1500
        Internet          576

### 滑动窗口
&emsp;&emsp; TCP以段作为发送单位，如果每次发送一个段进行一次确认应答，那么RTT时间越长，网络吞吐量就越差，因为这是基于同步的发送方式。
滑动窗口指无需等待确认应答ACK而继续发送数据的最大值。1，在滑动窗口机制下，前面的ACK丢失也能通过下一个ACK进行确认。2，发送端如果连续3次收到同一个
确认应答包，那么就会将其对应的数据进行重发。

    // ACK确认应答丢失
    如果一个段为1000字节，一个窗口为6000字节，发送端直接发送了6000字节的数据，中间1001的ACK丢失了，但如果后面的2001的ACK正常返回了，
    那么也说明前2000字节的数据都正常读取了，就不需要重传0-1000的数据。

    // 报文丢失
    如果段为1000，窗口为6000，1001-2000段丢失，那么在收到2001-3000时，依然会返回1001的ACK应答包，如果发送端连续收到同一个应答包，那么会重发。


### 流量控制
&emsp;&emsp; 如果发送端发送数据的速度太快，那么会导致接收端的缓冲区很快被填满，此时接收端会丢弃数据，从而导致发送端不断的重发。
TCP利用滑动窗口