* [1.TCP连接](#1)
* [2.TCP可靠传输机制](#2)

<h2 id="1">1.TCP连接</h2>
&emsp;&emsp; TCP连接经过三次握手，断开连接经过4次挥手。4此挥手时，断开发起方会在接收到FIN后，发送ACK，并等待2MS，然后再释放资源，
这是由于一个数据包最长存活时间为MSL(Maximum Segment Life)，如果发起方发送了ACK，那么如果另一方如果没收到会重传FIN，一来一回是就是2MSL。
而且，如果没有等待2MSL，那么新建立的连接可能会接收到旧连接的报文。

### CLOSE_WAIT及TIME_WAIT异常
&emsp;&emsp; CLOSE_WAIT只会出现在被断开连接的一方，出现大量CLOSE_WAIT的原因可能是一方发起了断开连接请求，另一方忙于读或者写，
没有关闭连接。TIME_WAIT大量出现，会导致端口耗尽。

    // TCP连接建立过程。
    1，主机A向主机B发起TCP连接，发送一条SYN报文，此时A主机状态从CLOSED变为SYN-SEND。
    2，主机B处于LISTEN状态，主机B接收到SYN包后，状态从LISTEN变成SYN-RECV，然后向主机A发送针对此SYN包的SYN/ACK包，确认收到SYN包。
    3，主机A收到SYN/ACK包后，状态从SYN-SEND转换为ESTABLISHED，然后向主机B发送SYN/ACK包。主机B收到SYN/ACK包后，也进入ESTABLISHED状态，
        此时主机A、B就能进行通信了。

                                A CLOSED                B LISTEN
                                 SYN-SEND ------------> SYN-RECV
                                               SYN
                              ESTABLISHED <------------ 
                                             SYN/ACK
                                          ------------> ESTABLISHED
                                             SYN/ACK

    // TCP连接断开过程。
    1，主机A向主机B发送FIN包，此时主机A状态从ESTABLISHED变成FIN_WAIT_1。
    2，主机B收到主机A发来的FIN包，状态从ESTABLISHED变为CLOSE_WAIT，并向主机A发送ACK包，表示准备断开。主机A在收到ACK包后，
        状态从FIN_WAIT_1变成FIN_WAIT_2，然后等待主机B发送确认断开的包。
    3，主机B在发送完所有未发送的数据包后，会再发送FIN包，此时主机B从CLOSE_WAIT状态，变为LAST_ACK状态。
    4，主机A收到主机B发送来的FIN包后，主机A状态从FIN_WAIT_2变为TIME_WAIT，然后发送ACK包，在等待2MSL后，如果还是没有收到回复，
        那么证明服务器已经正常关闭。主机B收到ACK包后，状态从LAST_ACK变为CLOSED。

                            A ESTABLISHED               B ESTABLISHED
                                FIN_WAIT_1 -----------> CLOSE_WAIT
                                               FIN
                                FIN_WAIT_2 <----------- 
                                               ACK   
                                TIME_WAIT  <----------- LAST_ACK   
                                               FIN
                                           -----------> CLOSED
                                               ACK

<h2 id="2">2.TCP可靠传输机制</h2>
&emsp;&emsp; TCP是一种可靠的数据传输协议。TCP确保数据无差错、不丢失、不重复、按序到达。

    TCP可靠传输特性：
        1，序列号和确认应答信号。
        2，超时重发控制。
        3，连接管理。
        4，滑动窗口控制。
        5，流量控制。
        6，拥塞控制。

### 通过序列号和确认应答信号提高可靠性
&emsp;&emsp; 当发送端的数据到达接收端时，接收端会返回一个已收到消息的通知，这个消息叫确认应答(ACK)，接收端查询接收数据TCP首部中的序列号和数据
长度，将自己下一步应该接收的序列号作为确认应答返回。通过序列号和确认应答号，TCP能识别是否已经接收数据，又能判断是否需要接收，从而实现可靠传输。

### 超时重发
&emsp;&emsp; 超时重发是指在重发数据之前，等待确认应答到来的时间间隔，如果超过这个时间仍未收到确认应答，发送端将进行数据重发。
TCP无论在何种网络环境下都要提供高性能通信，因此每次发包时都会计算往返时间(RTT round trip time)和偏差(RTT波动的时间)，将RTT和偏差时间相加，
重发超时的时间就比这个总和稍大一点。
    
    在BSD的Unix及Windows中，超时都以0.5秒为单位进行控制，因此重发超时都是0.5秒的整数倍，最初其重发超时默认值一般为6秒。数据重发后如果还是收不到
    确认应答，等待确认应答的时间将会以2倍、4倍的指数函数延长。达到一定重发次数后，如果还是没有任何确认应答返回，就会判断网络或接收端发生了异常，
    进而强制关闭连接。

### 连接管理
&emsp;&emsp; TCP通过三次握手建立连接和四次挥手断开连接。在数据通信前做好了通信两端之间的准备工作。在建立连接的时候，可以确定发送数据包的单位，
我们称之为最大消息长度(MSS max segment size)，也就是一个段。最理想的情况是，最大消息长度正好是IP中不会被分片处理的最大数据长度。TCP在发送
数据时，是以MSS的大小将数据进行分割发送，进行重发时也是以MSS为单位。 MSS是在三次握手时，两端主机告诉对方自己能适应的MSS大小，
然后在两者之间选择一个较小的值使用。
    
    MTU(maximum transmission unit)最大传输单元：是指一种通信协议的某一层上能通过的最大数据包大小，通常与通信接口有关。
    以太网为例，去除以太网的帧头，剩下1500Bytes，这部分用来表示IP层能够使用的字节大小，IP层包含IP首部，TCP、UDP最终都被封装成了IP包。
    
    MSS = MTU - 20Bytes IP首部 - 20Bytes TCP首部，因此以太网的MSS为1460字节，Internet MSS为536字节，超通道MSS为65495字节。
    IP包协议头段总长度占16bit，因此MSS最大值为：2^16 - 1 - 20 - 20 = 65495。TCP会根据MSS，将业务数据分片成若干个IP包，而不是直接将数据
    交给IP层来分片。TCP首部包括：目标端口、源端口、顺序号、确认号、窗口、校验和等。IP首部包括：总长度、目标地址、源地址、首部校验和等。
    
        网络              MTU(Byte)
        超通道             65535
        以太网             1500
        Internet          576

### 滑动窗口
&emsp;&emsp; TCP以段作为发送单位，如果每次发送一个段进行一次确认应答，那么RTT时间越长，网络吞吐量就越差，因为这是基于同步的发送方式。
滑动窗口指无需等待确认应答ACK而继续发送数据的最大值。1，在滑动窗口机制下，前面的ACK丢失也能通过下一个ACK进行确认。2，发送端如果连续3次收到同一个
确认应答包，那么就会将其对应的数据进行重发。

    // ACK确认应答丢失
    如果一个段为1000字节，一个窗口为6000字节，发送端直接发送了6000字节的数据，中间1001的ACK丢失了，但如果后面的2001的ACK正常返回了，
    那么也说明前2000字节的数据都正常读取了，就不需要重传0-1000的数据。

    // 报文丢失
    如果段为1000，窗口为6000，1001-2000段丢失，那么在收到2001-3000时，依然会返回1001的ACK应答包，如果发送端连续收到同一个应答包，那么会重发。


### 流量控制
&emsp;&emsp; 如果发送端发送数据的速度太快，那么会导致接收端的缓冲区很快被填满，此时接收端会丢弃数据，从而导致发送端不断的重发。
TCP利用滑动窗口实现流量控制机制，滑动窗口的大小是通过TCP首部的16位窗口大小字段来通知对方。接收端会在确认应答发送ACK报文时，
将自己的即时窗口大小rwnd(receiver window)填入，并跟随ACK发送。发送方端则根据ACK报文里窗口大小的值来改变自己的发送速度。
    
    在接收端缓冲区满了之后，会返回窗口大小为0，发送端会停止发送，等接收端处理完缓冲区数据后，会发送一个窗口更新的数据包，
    接收端接收到确认包后才会继续发送数据。如果接收端在超时重发的时间内都没有收到窗口更新或者窗口更新包丢失了，
    那么就没办法正常通信了，为了解决这个问题，TCP每一个连接都会设有一个持续计时器(persistence timer)。
    
    持续计时器：只要TCP连接的一放收到零窗口通知，就启动计时器，若持续计时器设置的时间到期，那么就发送一个零窗口探测数据段。
        持续计时器的值为重传时间的数值，如果发送了零窗口探测数据段，没有收到接收端的响应，那么持续计时器的值将加倍并复位。
        持续计时器的值最大可以增加到门限值，通常为60秒，在这之后发送端不在增加计时器的值，以固定频率发送探测报文，直到窗口更新。
        
### 拥塞控制
&emsp;&emsp; 某段时间内网络中要发送的数据包太多，设备处理不来就会导致网络性能下降，这就是拥塞。网络中的路由器会有一个数据包处理队列，
当路由器接收到的数据包太多处理不过来，就会导致数据包处理队列过长，此时路由器会丢弃新接收到的数据包，而丢弃数据包会引发TCP重传，
而路由器会继续丢弃重传的数据包，从而导致网络性能急剧下降，引发网络瘫痪。因此TCP要控制数据包发送的数量来避免网络性能的下降。

    有了TCP的滑动窗口控制收发数据以窗口而不是段来进行。但实际上还是会根据MSS来进行IP分片发送，传统的发送需要每次发送都接收ACK，
    才进行下一次发送，滑动窗口能够允许连续发送多个数据包。
    如果一开始连接就发送大量的数据包，那么可能导致网络瘫痪，在拥塞控制中，发送方维持一个拥塞窗口cwnd(congestion window)。
    
    拥塞控制使用了两种算法：慢启动算法、拥塞避免算法。ssthresh(慢启动门限)，cwnd < ssthresh 使用慢启动算法，
        cwnd > ssthresh使用拥塞避免算法，两者相等使用任一算法都行。 无论慢启动阶段还是拥塞避免阶段，出现拥塞(未按时收到ACK)，
        就会把ssthresh值设置为cwnd的一半并且大于等于2.
        
        1，慢启动算法：一开始发送少量数据，试探网络拥堵程度，每个传输轮次后将cwnd加倍。比如开始发送设置cwnd=1报文段，
        在第一轮发送完成后加倍，第二轮窗口中数据都发送完成后再次加倍。但不可能一直指数增加cwnd，因此经过一段时间指数增长后，
        需要换成拥塞避免算法来发送数据。
        2，拥塞避免算法：每个传输轮次后，将cwnd的大小加一，出现网络拥塞就将ssthresh设置为cwnd的一半，并将cwnd设置为1，
        重新执行慢启动算法。
